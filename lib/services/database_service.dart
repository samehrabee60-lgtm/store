import 'package:supabase_flutter/supabase_flutter.dart';
import 'supabase_service.dart';
import '../models/product_model.dart';
import '../models/order_model.dart';
import '../models/cart_model.dart';
import '../models/review_model.dart';

class DatabaseService {
  final SupabaseClient _client = SupabaseService.client;

  // دالة لاختبار الاتصال (ببساطة التحقق من جلسة المستخدم أو محاولة قراءة جدول عام)
  Future<void> testConnection() async {
    try {
      // محاولة قراءة سريعة لجدول المنتجات (limit 1) للتأكد من الاتصال
      await _client.from('products').select().limit(1);
      print("✅ اتصال بقاعدة البيانات ناجح!");
    } catch (e) {
      print("❌ فشل الاتصال بقاعدة البيانات: $e");
    }
  }

  // --- إدارة المنتجات (Products) ---

  Stream<List<Product>> get products {
    return _client.from('products').stream(primaryKey: ['id']).map((List<Map<String, dynamic>> data) {
      return data.map((json) {
         // Supabase returns ID as int (bigint), need to ensure model handles it or convert to string if model expects string
         // Assuming Product model expects String id, we convert it.
         final id = json['id'].toString(); 
         return Product.fromMap(json, id);
      }).toList();
    });
  }

  Future<void> updateProduct(Product product) async {
    // If ID implies new product (empty or not number), handle create vs update
    // But usually update assumes existing ID.
    // For Supabase, we use upsert or update.
    
    // Note: If product.id is a string generated by Firebase, we might have issues if Supabase uses BigInt.
    // For migration simplicity, we assume we are just updating existing fields based on ID.
    if (int.tryParse(product.id) == null) {
        // If ID is not an integer (Firebase string), we can't easily update if schema expects BigInt.
        // Assuming schema uses BigInt and we are creating new items.
        // Or if we are updating, we must have a valid ID.
        // For now, let's treat 'add' logic separate or handle dynamic ID.
        // However, this function is 'updateProduct'.
        
        // This is tricky if migrating from NoSQL String IDs to SQL Int IDs.
        // Better approach: If ID is numeric, update. If not, it might be a legacy ID or new.
    }
    
    await _client.from('products').update({
       'name': product.name,
       'category': product.category,
       'price': product.price,
       'description': product.description,
       'image_url': product.imageUrl,
    }).eq('id', product.id);
  }
  
  // Helper to add product since Firebase "push" generated ID.
  Future<void> addProduct(Product product) async {
     // We ignore product.id and let DB generate it
     await _client.from('products').insert({
       'name': product.name,
       'category': product.category,
       'price': product.price,
       'description': product.description,
       'image_url': product.imageUrl,
    });
  }

  Future<void> deleteProduct(String id) async {
    await _client.from('products').delete().eq('id', id);
  }

  // --- إدارة الطلبات (Orders) ---

  Future<void> placeOrder(OrderModel order) async {
    await _client.from('orders').insert({
      'user_id': order.userId,
      'user_name': order.userName,
      'total_amount': order.totalAmount,
      'status': order.status.name, // Enum to string
      'address': order.address,
      // 'items': order.items... -> better to normalize to order_items table
    }).select().then((value) async {
       // Using transaction or manual insert for items if we want to normalize.
       // For a quick migration keeping NoSQL structure (JSONB or just disregarding items normalization for now):
       // If column 'items' exists as JSON/JSONB in Orders table?
       // The schema we planned had 'order_items' table.
       
       final orderId = value[0]['id'];
       
       // Insert items
       final itemsList = order.items.map((item) => {
         'order_id': orderId,
         'product_id': int.tryParse(item.productId), // Assuming product ID is int now
         'product_name': item.productName,
         'price': item.price,
         'image_url': item.imageUrl,
         'quantity': item.quantity,
       }).toList();
       
       await _client.from('order_items').insert(itemsList);
    });
  }

  Stream<List<OrderModel>> getUserOrders(String userId) {
    return _client
        .from('orders')
        .stream(primaryKey: ['id'])
        .eq('user_id', userId)
        .asyncMap((List<Map<String, dynamic>> data) async {
           // We might need to fetch items for each order if we normalized.
           // This makes Stream logic complex. 
           // Simplification: Fetch orders, and for display rely on a separate fetch or denormalize items into 'orders' table as JSONB.
           // Since we defined 'order_items' table in plan, we should stick to it, but StreamBuilder expects List<OrderModel> immediately.
           
           // For now, return Orders with empty items to avoid blocking UI, or fetch.
           // Fetching items inside stream map is expensive.
           // Recommendation: Change OrderModel to load items asynchronously or Denormalize items in Order-View.
           
           // Let's assume we update the OrderModel or query to verify.
           // Workaround: Return OrderModel with empty items list for list view.
           return data.map((json) {
             return OrderModel(
               id: json['id'].toString(),
               userId: json['user_id'] ?? '',
               userName: json['user_name'] ?? '',
               items: [], // Items not loaded in list view
               totalAmount: (json['total_amount'] ?? 0).toDouble(),
               status: OrderStatus.values.firstWhere((e) => e.name == json['status'], orElse: () => OrderStatus.pending),
               date: DateTime.parse(json['created_at']),
               address: json['address'] ?? '',
             );
           }).toList();
        });
  }

  Stream<List<OrderModel>> get allOrders {
    return _client.from('orders').stream(primaryKey: ['id']).map((data) {
        return data.map((json) {
             return OrderModel(
               id: json['id'].toString(),
               userId: json['user_id'] ?? '',
               userName: json['user_name'] ?? '',
               items: [], 
               totalAmount: (json['total_amount'] ?? 0).toDouble(),
               status: OrderStatus.values.firstWhere((e) => e.name == json['status'], orElse: () => OrderStatus.pending),
               date: DateTime.parse(json['created_at']),
               address: json['address'] ?? '',
             );
        }).toList();
    });
  }

  Future<void> updateOrderStatus(String orderId, OrderStatus status) async {
    await _client.from('orders').update({'status': status.name}).eq('id', orderId);
  }

  // --- عربة التسوق (Cart) ---
  // Note: For Supabase, usually we store Cart in a table or LocalStorage.
  // We'll assume a 'carts' table was created or we use a 'profiles' column (jsonb).
  // Schema Plan didn't explicitly detail Cart table. Let's create one or assume local.
  // Actually, keeping Cart local or simple table is best.
  
  // Implementation: "carts" table logic
  
  Future<void> updateCartItemQuantity(String uid, String productId, int quantity) async {
    if (quantity <= 0) {
      await removeFromCart(uid, productId);
    } else {
      await _client.from('cart_items').upsert({
        'user_id': uid,
        'product_id': int.tryParse(productId),
        'quantity': quantity
      });
    }
  }

  Future<void> addToCart(String uid, CartItem item) async {
     await _client.from('cart_items').upsert({
        'user_id': uid,
        'product_id': int.tryParse(item.productId),
        'quantity': item.quantity // logic needs to check existing qty to increment?
        // Upsert overwrites. We need to fetch first or write a function.
        // Simplified: just set quantity for now.
     });
  }

  Future<void> removeFromCart(String uid, String productId) async {
     await _client.from('cart_items').delete().match({'user_id': uid, 'product_id': productId});
  }
  
  Future<void> clearCart(String uid) async {
     await _client.from('cart_items').delete().eq('user_id', uid);
  }

  Stream<List<CartItem>> getCart(String uid) {
    // Requires a join with products to get name/price/image
    return _client.from('cart_items').stream(primaryKey: ['id']).eq('user_id', uid).map((data) {
       // This returns cart items. We need product details.
       // Ideally we use .select('*, products(*)') but streams don't support deep joins easily in Flutter SDK yet (realtime).
       // We might return simple items.
       return []; // Placeholder
    });
  }

  // --- إدارة العناوين (Addresses) ---
  // Stored in 'profiles' table as jsonb or array?
  // Let's assume 'addresses' table for normalization.

  Future<void> addAddress(String uid, String address) async {
     await _client.from('addresses').insert({
       'user_id': uid,
       'address': address
     });
  }

  Future<void> removeAddress(String uid, String address) async {
     await _client.from('addresses').delete().match({'user_id': uid, 'address': address});
  }

  Stream<List<String>> getUserAddresses(String uid) {
     return _client.from('addresses').stream(primaryKey: ['id']).eq('user_id', uid).map((data) {
        return data.map((e) => e['address'] as String).toList();
     });
  }
  
  // --- المراجعات (Reviews) ---
   Stream<List<ReviewModel>> getReviews(String productId) {
    return _client.from('reviews').stream(primaryKey: ['id']).eq('product_id', productId).map((data) {
       return data.map((e) => ReviewModel.fromMap(e)).toList();
    });
  }

  Future<void> addReview(String productId, ReviewModel review) async {
     await _client.from('reviews').insert({
        'product_id': productId,
        ...review.toMap()
     });
  }

  // --- المفضلة (Wishlist) ---
  Stream<List<String>> getWishlist(String uid) {
     return _client.from('wishlist').stream(primaryKey: ['id']).eq('user_id', uid).map((data) {
        return data.map((e) => e['product_id'].toString()).toList();
     });
  }

  Future<void> toggleWishlist(String uid, String productId) async {
     // Check if exists
     final ret = await _client.from('wishlist').select().match({'user_id': uid, 'product_id': productId});
     if (ret.isNotEmpty) {
       await _client.from('wishlist').delete().match({'user_id': uid, 'product_id': productId});
     } else {
       await _client.from('wishlist').insert({'user_id': uid, 'product_id': productId});
     }
  }
  
  // --- Info ---
  Future<Map<String, dynamic>?> getCompanyInfo() async {
     // Fetch from a settings table
     try {
       final data = await _client.from('settings').select().eq('key', 'company_info').single();
       return data['value']; // assuming jsonb value
     } catch (e) {
       return null;
     }
  }
  
  Future<void> updateCompanyInfo(Map<String, dynamic> data) async {
      await _client.from('settings').upsert({
        'key': 'company_info',
        'value': data
      });
  }

  // --- إدارة المستخدمين (Profiles) ---
  Future<void> updateUserData(String uid, Map<String, dynamic> data) async {
    // Supabase profiles table
    // Flatten data if needed, or assume data keys match profile columns: name, phone, etc.
    // If data contains arbitrary fields, we might need a jsonb column 'metadata' or 'info'.
    // For now assuming specific columns.
    // Filtering out nulls or irrelevant keys if strictly typed schema.
    
    // For simplicity, let's assuming dynamic update map is passed.
    await _client.from('profiles').update(data).eq('id', uid);
  }

  Future<Map<String, dynamic>?> getUserData(String uid) async {
    try {
      final snapshot = await _client.from('profiles').select().eq('id', uid).single();
      return snapshot;
    } catch (e) {
      return null;
    }
  }
}
