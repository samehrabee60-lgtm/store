import 'package:supabase_flutter/supabase_flutter.dart';
import 'supabase_service.dart';
import '../models/product_model.dart';
import '../models/order_model.dart';
import '../models/cart_model.dart';
import '../models/review_model.dart';

class DatabaseService {
  final SupabaseClient _client = SupabaseService.client;

  // دالة لاختبار الاتصال (ببساطة التحقق من جلسة المستخدم أو محاولة قراءة جدول عام)
  Future<void> testConnection() async {
    try {
      // محاولة قراءة سريعة لجدول المنتجات (limit 1) للتأكد من الاتصال
      // await _client.from('products').select().limit(1);
      // debugPrint("✅ اتصال بقاعدة البيانات ناجح!");
    } catch (e) {
      // debugPrint("❌ فشل الاتصال بقاعدة البيانات: $e");
    }
  }

  // --- إدارة المنتجات (Products) ---

  Stream<List<Product>> get products {
    return _client
        .from('products')
        .stream(primaryKey: ['id']).map((List<Map<String, dynamic>> data) {
      return data.map((json) {
        // Supabase returns ID as int (bigint), need to ensure model handles it or convert to string if model expects string
        // Assuming Product model expects String id, we convert it.
        final id = json['id'].toString();
        return Product.fromMap(json, id);
      }).toList();
    });
  }

  Future<void> updateProduct(Product product) async {
    // If ID implies new product (empty or not number), handle create vs update
    // But usually update assumes existing ID.
    // For Supabase, we use upsert or update.

    // Note: If product.id is a string generated by Firebase, we might have issues if Supabase uses BigInt.
    // For migration simplicity, we assume we are just updating existing fields based on ID.
    if (int.tryParse(product.id) == null) {
      // If ID is not an integer (Firebase string), we can't easily update if schema expects BigInt.
      // Assuming schema uses BigInt and we are creating new items.
      // Or if we are updating, we must have a valid ID.
      // For now, let's treat 'add' logic separate or handle dynamic ID.
      // However, this function is 'updateProduct'.

      // This is tricky if migrating from NoSQL String IDs to SQL Int IDs.
      // Better approach: If ID is numeric, update. If not, it might be a legacy ID or new.
    }

    await _client.from('products').update({
      'name': product.name,
      'category': product.category,
      'price': product.price,
      'description': product.description,
      'image_url': product.imageUrl,
      'pdf_url': product.pdfUrl,
      'additional_images': product.additionalImages,
    }).eq('id', product.id);
  }

  // Helper to add product since Firebase "push" generated ID.
  Future<void> addProduct(Product product) async {
    // We ignore product.id and let DB generate it
    await _client.from('products').insert({
      'name': product.name,
      'category': product.category,
      'price': product.price,
      'description': product.description,
      'image_url': product.imageUrl,
      'pdf_url': product.pdfUrl,
      'additional_images': product.additionalImages,
    });
  }

  Future<void> deleteProduct(String id) async {
    await _client.from('products').delete().eq('id', id);
  }

  // --- إدارة الطلبات (Orders) ---

  Future<void> placeOrder(OrderModel order) async {
    await _client
        .from('orders')
        .insert({
          'user_id': order.userId,
          'user_name': order.userName,
          'total_amount': order.totalAmount,
          'status': order.status.name, // Enum to string
          'address': order.address,
          // 'items': order.items... -> better to normalize to order_items table
        })
        .select()
        .then((value) async {
          // Using transaction or manual insert for items if we want to normalize.
          // For a quick migration keeping NoSQL structure (JSONB or just disregarding items normalization for now):
          // If column 'items' exists as JSON/JSONB in Orders table?
          // The schema we planned had 'order_items' table.

          final orderId = value[0]['id'];

          // Insert items
          final itemsList = order.items
              .map((item) => {
                    'order_id': orderId,
                    'product_id': int.tryParse(
                        item.productId), // Assuming product ID is int now
                    'product_name': item.productName,
                    'price': item.price,
                    'image_url': item.imageUrl,
                    'quantity': item.quantity,
                  })
              .toList();

          await _client.from('order_items').insert(itemsList);
        });
  }

  Stream<List<OrderModel>> getUserOrders(String userId) {
    return _client
        .from('orders')
        .stream(primaryKey: ['id'])
        .eq('user_id', userId)
        .asyncMap((List<Map<String, dynamic>> data) async {
          // We might need to fetch items for each order if we normalized.
          // This makes Stream logic complex.
          // Simplification: Fetch orders, and for display rely on a separate fetch or denormalize items into 'orders' table as JSONB.
          // Since we defined 'order_items' table in plan, we should stick to it, but StreamBuilder expects List<OrderModel> immediately.

          // For now, return Orders with empty items to avoid blocking UI, or fetch.
          // Fetching items inside stream map is expensive.
          // Recommendation: Change OrderModel to load items asynchronously or Denormalize items in Order-View.

          // Let's assume we update the OrderModel or query to verify.
          // Workaround: Return OrderModel with empty items list for list view.
          return data.map((json) {
            return OrderModel(
              id: json['id'].toString(),
              userId: json['user_id'] ?? '',
              userName: json['user_name'] ?? '',
              items: [], // Items not loaded in list view
              totalAmount: (json['total_amount'] ?? 0).toDouble(),
              status: OrderStatus.values.firstWhere(
                  (e) => e.name == json['status'],
                  orElse: () => OrderStatus.pending),
              date: DateTime.parse(json['created_at']),
              address: json['address'] ?? '',
            );
          }).toList();
        });
  }

  Stream<List<OrderModel>> get allOrders {
    return _client.from('orders').stream(primaryKey: ['id']).map((data) {
      return data.map((json) {
        return OrderModel(
          id: json['id'].toString(),
          userId: json['user_id'] ?? '',
          userName: json['user_name'] ?? '',
          items: [],
          totalAmount: (json['total_amount'] ?? 0).toDouble(),
          status: OrderStatus.values.firstWhere((e) => e.name == json['status'],
              orElse: () => OrderStatus.pending),
          date: DateTime.parse(json['created_at']),
          address: json['address'] ?? '',
        );
      }).toList();
    });
  }

  Future<void> updateOrderStatus(String orderId, OrderStatus status) async {
    await _client
        .from('orders')
        .update({'status': status.name}).eq('id', orderId);
  }

  // --- عربة التسوق (Cart) ---
  // Note: For Supabase, usually we store Cart in a table or LocalStorage.
  // We'll assume a 'carts' table was created or we use a 'profiles' column (jsonb).
  // Schema Plan didn't explicitly detail Cart table. Let's create one or assume local.
  // Actually, keeping Cart local or simple table is best.

  // Implementation: "carts" table logic

  Future<void> updateCartItemQuantity(
      String uid, String productId, int quantity) async {
    if (quantity <= 0) {
      await removeFromCart(uid, productId);
    } else {
      // Find the cart item to get its ID, or assume unique constraint on user_id + product_id
      // For safety, let's look it up
      final existing = await _client
          .from('cart_items')
          .select()
          .match({'user_id': uid, 'product_id': productId}).maybeSingle();

      if (existing != null) {
        await _client
            .from('cart_items')
            .update({'quantity': quantity}).eq('id', existing['id']);
      }
    }
  }

  Future<void> addToCart(String uid, CartItem item) async {
    final existing = await _client
        .from('cart_items')
        .select()
        .match({'user_id': uid, 'product_id': item.productId}).maybeSingle();

    if (existing != null) {
      final newQty = (existing['quantity'] as int) + item.quantity;
      await _client
          .from('cart_items')
          .update({'quantity': newQty}).eq('id', existing['id']);
    } else {
      await _client.from('cart_items').insert({
        'user_id': uid,
        'product_id': int.tryParse(item.productId),
        'quantity': item.quantity,
      });
    }
  }

  Future<void> removeFromCart(String uid, String productId) async {
    await _client
        .from('cart_items')
        .delete()
        .match({'user_id': uid, 'product_id': productId});
  }

  Future<void> clearCart(String uid) async {
    await _client.from('cart_items').delete().eq('user_id', uid);
  }

  Stream<List<CartItem>> getCart(String uid) {
    return _client
        .from('cart_items')
        .stream(primaryKey: ['id'])
        .eq('user_id', uid)
        .asyncMap((List<Map<String, dynamic>> cartData) async {
          if (cartData.isEmpty) return <CartItem>[];

          final productIds = cartData
              .map((e) => e['product_id'])
              .where((id) => id != null)
              .toList();

          if (productIds.isEmpty) return <CartItem>[];

          try {
            final productsData = await _client
                .from('products')
                .select()
                .filter('id', 'in', productIds);

            final productsMap = {
              for (var p in productsData)
                p['id'].toString(): Product.fromMap(p, p['id'].toString())
            };

            return cartData.map((cartItem) {
              final productId = cartItem['product_id'].toString();
              final product = productsMap[productId];

              // If product not found (deleted?), handle gracefully
              // For now we return the item with fallback data or filter it out?
              // Let's fallback to ensure the user can at least delete it from cart.

              return CartItem(
                productId: productId,
                productName: product?.name ?? 'منتج غير متاح',
                price: product?.price ?? 0.0,
                imageUrl: product?.imageUrl ?? '',
                quantity: cartItem['quantity'] ?? 1,
              );
            }).toList();
          } catch (e) {
            // debugPrint("Error fetching cart products: $e");
            return <CartItem>[];
          }
        });
  }

  // --- إدارة العناوين (Addresses) ---
  // Stored in 'profiles' table as jsonb or array?
  // Let's assume 'addresses' table for normalization.

  Future<void> addAddress(String uid, String address) async {
    await _client
        .from('addresses')
        .insert({'user_id': uid, 'address': address});
  }

  Future<void> removeAddress(String uid, String address) async {
    await _client
        .from('addresses')
        .delete()
        .match({'user_id': uid, 'address': address});
  }

  Stream<List<String>> getUserAddresses(String uid) {
    return _client
        .from('addresses')
        .stream(primaryKey: ['id'])
        .eq('user_id', uid)
        .map((data) {
          return data.map((e) => e['address'] as String).toList();
        });
  }

  // --- المراجعات (Reviews) ---
  Stream<List<ReviewModel>> getReviews(String productId) {
    return _client
        .from('reviews')
        .stream(primaryKey: ['id'])
        .eq('product_id', productId)
        .map((data) {
          return data.map((e) => ReviewModel.fromMap(e)).toList();
        });
  }

  Future<void> addReview(String productId, ReviewModel review) async {
    await _client
        .from('reviews')
        .insert({'product_id': productId, ...review.toMap()});
  }

  // --- المفضلة (Wishlist) ---
  Stream<List<String>> getWishlist(String uid) {
    return _client
        .from('wishlist')
        .stream(primaryKey: ['id'])
        .eq('user_id', uid)
        .map((data) {
          return data.map((e) => e['product_id'].toString()).toList();
        });
  }

  Future<void> toggleWishlist(String uid, String productId) async {
    // Check if exists
    final ret = await _client
        .from('wishlist')
        .select()
        .match({'user_id': uid, 'product_id': productId});
    if (ret.isNotEmpty) {
      await _client
          .from('wishlist')
          .delete()
          .match({'user_id': uid, 'product_id': productId});
    } else {
      await _client
          .from('wishlist')
          .insert({'user_id': uid, 'product_id': productId});
    }
  }

  // --- Info ---
  Future<Map<String, dynamic>?> getCompanyInfo() async {
    // Fetch from a settings table
    try {
      final data = await _client
          .from('settings')
          .select()
          .eq('key', 'company_info')
          .single();
      return data['value']; // assuming jsonb value
    } catch (e) {
      return null;
    }
  }

  Future<void> updateCompanyInfo(Map<String, dynamic> data) async {
    await _client
        .from('settings')
        .upsert({'key': 'company_info', 'value': data});
  }

  // --- إدارة المستخدمين (Profiles) ---
  Future<void> updateUserData(String uid, Map<String, dynamic> data) async {
    // Supabase profiles table
    // Flatten data if needed, or assume data keys match profile columns: name, phone, etc.
    // If data contains arbitrary fields, we might need a jsonb column 'metadata' or 'info'.
    // For now assuming specific columns.
    // Filtering out nulls or irrelevant keys if strictly typed schema.

    // For simplicity, let's assuming dynamic update map is passed.
    await _client.from('profiles').update(data).eq('id', uid);
  }

  Future<Map<String, dynamic>?> getUserData(String uid) async {
    try {
      final snapshot =
          await _client.from('profiles').select().eq('id', uid).single();
      return snapshot;
    } catch (e) {
      return null;
    }
  }

  // --- إدارة الأعضاء (Admin: Users Management) ---
  Stream<List<Map<String, dynamic>>> get allUsers {
    return _client
        .from('profiles')
        .stream(primaryKey: ['id'])
        .eq('role', 'client') // Fetch only clients
        // .or('role.eq.banned') // Supabase stream filter limitations might apply
        .map((data) => data);
  }

  // Fetch all users including banned ones (Future version might be safer for complex filters)
  Future<List<Map<String, dynamic>>> getAllUsers() async {
    final data = await _client.from('profiles').select().neq('role', 'admin');
    return List<Map<String, dynamic>>.from(data);
  }

  Future<void> toggleUserBan(String uid, bool ban) async {
    await _client
        .from('profiles')
        .update({'role': ban ? 'banned' : 'client'}).eq('id', uid);
  }

  Future<void> deleteUser(String uid) async {
    // Note: This only deletes the profile record.
    // The auth user remains unless deleted via Admin API (backend).
    await _client.from('profiles').delete().eq('id', uid);
  }

  // --- إدارة البنرات (Banners) ---
  Stream<List<String>> get banners {
    return _client
        .from('banners')
        .stream(primaryKey: ['id'])
        .order('created_at',
            ascending: false) // Show newest first or custom order
        .map((data) {
          return data.map((e) => e['image_url'] as String).toList();
        });
  }

  Future<void> addBanner(String imageUrl) async {
    await _client.from('banners').insert({
      'image_url': imageUrl,
      'active': true, // Optional: if logic uses it
    });
  }

  Future<void> deleteBanner(String imageUrl) async {
    await _client.from('banners').delete().eq('image_url', imageUrl);
  }

  // --- إدارة الكوبونات (Coupons) ---
  Stream<List<Map<String, dynamic>>> get coupons {
    return _client
        .from('coupons')
        .stream(primaryKey: ['code']).map((data) => data);
  }

  Future<void> addCoupon({
    required String code,
    required String discountType,
    required num value,
    required DateTime expiryDate,
  }) async {
    await _client.from('coupons').insert({
      'code': code.toUpperCase(),
      'discount_type': discountType, // 'percentage' or 'fixed'
      'value': value,
      'expiry_date': expiryDate.toIso8601String(),
    });
  }

  Future<void> deleteCoupon(String code) async {
    await _client.from('coupons').delete().eq('code', code);
  }

  Future<Map<String, dynamic>?> checkCoupon(String code) async {
    try {
      final data = await _client
          .from('coupons')
          .select()
          .eq('code', code.toUpperCase())
          .maybeSingle();

      // Check expiry
      if (data != null) {
        final expiry = DateTime.parse(data['expiry_date']);
        if (DateTime.now().isAfter(expiry)) {
          return null; // Expired
        }
      }
      return data;
    } catch (e) {
      return null;
    }
  }
}
